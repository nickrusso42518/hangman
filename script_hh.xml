<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>hangman_helper</name>
			<packageName></packageName>
			<script>-- Author: Nick Russo (njrusmc@gmail.com)
-- Usage: Call hangman_helper() from aliases or triggers to offer suggestions

function hangman_helper(word_in_process, wrong_letters)
  -- Some user-defined constants that don't often change are embedded in
  -- the script to simplify the CLI arguments
  local PER_LINE = 12
  local FILENAME = "/Users/nicholasrusso/Desktop/MM/words.txt"
  
  -- First, normalize wrong letters by removing any spaces
  wrong_letters = string.gsub(wrong_letters, " ", "")
  
  -- To determine already-guessed right letters, iterate over the word in
  -- process to extract one of each letter
  local right_letters = ""
  for i = 1, #word_in_process do
    local char = string.sub(word_in_process, i, i)
  
    -- If it's not an underscore and not yet recorded as as right letter, add it
    if char ~= "_" and not string.find(right_letters, char) then
      right_letters = right_letters..char
    end
  end
  
  -- Underscores should be replaced with a character set that excludes both
  -- the already-guessed right and wrong letters. This will narrow down the
  -- search criteria and prevent false positives
  local blank_replacer = "[^"..right_letters..wrong_letters.."]"
  
  -- The final pattern takes the word in process, replaces underscores with
  -- the aforementioned character set, then anchors the string to ensure
  -- the word length matches the candidate length
  local pattern = "^"..string.gsub(word_in_process, "_", blank_replacer).."$"
  
  local throwaway_comment = [[
  -- Useful debugging information to ensure core logic variables are correct
  echo("word_in_process: "..word_in_process.."\n")
  echo("wrong_letters: "..wrong_letters.."\n")
  echo("right_letters: "..right_letters.."\n")
  echo("blank_replacer: "..blank_replacer.."\n")
  echo("pattern: "..pattern.."\n")
  ]]
  
  -- Open the word file for reading only, and if it fails, display the
  -- error message and quit
  local handle = assert(io.open(FILENAME, "r"))
  
  -- Alternative shorthand syntax for reading in all words from the
  -- file as a giant string, then matching contiguous blocks of
  -- non-whitespace characters. This returns an iterator with "next" logic
  local words_text = handle:read("*all")
  local words_iter = words_text:gmatch("%S+")
  
  -- Initialize a counter and start looping over the iterator to display
  -- each candidate word
  local i = 0
  for candidate in words_iter do
  
    -- Get the first and last indices of any word that matches the pattern
    first, last = string.find(candidate, pattern)
    if first ~= nil and #word_in_process == #candidate then
  
      -- Match occurred and with proper length; display word and increment i
      echo(candidate)
      i = i + 1
  
      -- If we reached the line max, print newline, else use comma separation.
      -- Logic collapsed onto one line for brevity, but not required
      if i % PER_LINE == 0 then echo("\n") else echo(", ") end
    end
  end
  echo("\n\n")
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
</MudletPackage>
